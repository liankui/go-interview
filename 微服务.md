# 微服务

1、什么是微服务

微服务架构风格是将单个应用程序作为一组小型服务开发的方法，每个服务程序都在自己的进程中运行，并与轻量级机制（通常是HTTP资源API）进行通信。这些服务是围绕业务功能构建的。可以通过全自动部署机器独立部署。这些服务器可以用不同的编程语言编写，使用不同的数据存储技术，并尽量不用集中式方式进行管理。

1.1 使用微服务的优势

- 开发简单
  微服务架构将复杂系统进行拆分之后，让每个微服务应用都开放变得非常简单，没有太多的累赘。对于每一个开发者来说，这无疑是一种解脱，因为再也不用进行繁重的劳动了，每天都在一种轻松愉快的氛围中工作，其效率也会整备地提高
- 快速响应需求变化
  一般的需求变化都来自于局部功能的改变，这种变化将落实到每个微服务上，每个微服务的功能相对来说都非常简单，更改起来非常容易，所以微服务非常适合敏捷开发方法，能够快速的影响业务的需求变化。
- 随时随地更新
  一方面，微服务的部署和更新并不会影响全局系统的正常运行；另一方面，使用多实例的部署方法，可以做到一个服务的重启和更新在不易察觉的情况下进行。所以每个服务任何时候都可以进行更新部署。
- 系统更加稳定可靠
  微服务运行在一个高可用的分布式环境之中，有配套的监控和调度管理机制，并且还可以提供自由伸缩的管理，充分保障了系统的稳定可靠性
2、怎么划分服务（DDD那一套）

1.服务职责尽量单一化
2.服务的粒度适中
3.考虑团队的结构
4.以业务模型作为切入点
5.演进式拆分
6.避免环形依赖和双向依赖问题

3、服务治理（包括但不限于：限流，熔断、负载、监控、鉴权、服务发现和注册等等）

限流

API请求限制

开发者为前端提供的API接口都是有访问上限的，当访问频率或者并发量超过其承受范围时候，我们就必须考虑限流来保证接口的可用性或者降级可用性。即接口也需要安装上保险丝，以防止非预期的请求对系统压力过大而引起的系统瘫痪。

限流方案是基于 `redis` 计数器，通过调用 `redis lua script` ，保证计数过程的原子性，同时保证在分布式的情况下计数是正常的。但是这种方案存在缺点，因为它要记录时间窗口内的所有行为记录，如果这个量特别大的时候，内存消耗会变得非常严重。

用户token限制

令牌桶生产token逻辑如下：

- 用户配置的平均发送速率为r，则每隔1/r秒一个令牌被加入到桶中；
- 假设桶中最多可以存放b个令牌。如果令牌到达时令牌桶已经满了，那么这个令牌会被丢弃；
- 当流量以速率v进入，从桶中以速率v取令牌，拿到令牌的流量通过，拿不到令牌流量不通过，执行熔断逻辑；

`tokenlimit` 限流方案适用于瞬时流量冲击，现实请求场景并不以恒定的速率。令牌桶相当预请求，当真实的请求到达不至于瞬间被打垮。当流量冲击到一定程度，则才会按照预定速率进行消费。

布隆过滤器，可以判断某元素在不在集合里面。一般的使用场景是:防止缓存击穿(防止恶意攻击)、 垃圾邮箱过滤、cache digests 、模型检测器等、判断是否存在某行数据,用以减少对磁盘访问，提高服务的访问性能。

熔断

熔断机制其实是参考了我们日常生活中的保险丝的保护机制，当电路超负荷运行时，保险丝会自动的断开，从而保证电路中的电器不受损害。而服务治理中的熔断机制，指的是在发起服务调用的时候，如果被调用方返回的错误率超过一定的阈值，那么后续的请求将不会真正发起请求，而是在调用方直接返回错误。

参考了[Google Sre过载保护算法](https://landing.google.com/sre/sre-book/chapters/handling-overload/#eq2101)，该算法的原理如下：

- 请求数量(requests)：调用方发起请求的数量总和
- 请求接受数量(accepts)：被调用方正常处理的请求数量

在正常情况下，这两个值是相等的，随着被调用方服务出现异常开始拒绝请求，请求接受数量(accepts)的值开始逐渐小于请求数量(requests)，这个时候调用方可以继续发送请求，直到requests = K * accepts，一旦超过这个限制，熔断器就回打开，新的请求会在本地以一定的概率被抛弃直接返回错误。

自适应降载

目的

- 保证系统不被过量请求拖垮
- 在保证系统稳定的前提下，尽可能提供更高的吞吐量

考虑因素

- 如何衡量系统负载
    - 是否处于虚机或容器内，需要读取cgroup相关负载
    - 用1000m表示100%CPU，推荐使用800m表示系统高负载
- 尽可能小的Overhead，不显著增加RT
- 不考虑服务本身所依赖的DB或者缓存系统问题，这类问题通过熔断机制来解决

- 基本功能层面
    1. 并发控制 & 限流，避免服务被突发流量击垮
    2. 服务注册与服务发现，确保能够动态侦测增减的节点
    3. 负载均衡，需要根据节点承受能力分发流量
    4. 超时控制，避免对已超时请求做无用功
    5. 熔断设计，快速失败，保障故障节点的恢复能力
- 高阶功能层面
    1. 请求认证，确保每个用户只能访问自己的数据
    2. 链路追踪，用于理解整个系统和快速定位特定请求的问题
    3. 日志，用于数据收集和问题定位
    4. 可观测性，没有度量就没有优化

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/14296b70-3ac1-4487-a755-b6530b26287e/Untitled.png)
4、rpc

[RPC通信](https://www.notion.so/RPC-72212d7cc73343a186bfbec18addfd79)

微服务直接是通过gRPC框架进行通信,跨平台通讯格式为Protobuf

gRPC 是一个高性能、开源和通用的 RPC 框架，面向移动端,gRPC基于 HTTP/2标准设计，带来诸如双向流、 流控、头部压缩、单 TCP连接上的多复用请求等特。这些特性使得其在移动设备上表现更好，更省电和节省空间占用。
gRPC默认使用protoBuf，这是 Google开源的一套成熟的结构数据序列化机制.在配合使用下,在跨平台,跨语言,跨设备等情况的支持都比较好,并且现在谷歌最新的api已经开始推出gRPC接口,可以很轻松的讲Google功能集成到项目当中

5、protobuf 编码为什么这么高效？和 json 比较呢？

**优势：**

1. 序列化后体积相比Json和XML很小，适合网络传输
2. 支持跨平台多语言
3. 消息格式升级和兼容性还不错
4. 序列化反序列化速度很快，快于Json的处理速度

**劣势：**

1. 应用不够广(相比xml和json)
2. 二进制格式导致可读性差
3. 缺乏自描述


6、gateway
