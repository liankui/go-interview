# Mysql
## 1、索引
索引是关系数据库中对某⼀列的值进⾏预排序的数据结构。通过使⽤索引，可以让数据库不必扫描整张表，⽽是直接定位到符合条件的记录，这样⼤⼤加快了查询速度。
    
### 1.1 索引创建原则（什么情况下用和不用）
1. 用于频繁搜索的列
2. 用于排序的字段
3. 做条件查询的列
4. 如果列中仅仅包含几个不同的值不要设置索引
5. 如果数据量不大就不用做索引，因为通过索引查找数据比全表扫描所花的时间更长。


### 1.2 索引的数据结构，b+树和一般二叉树、平衡二叉树、hash树、b树的区别

**索引为什么⽤B+树**
1. 单⼀节点存储更多元素，使得查询的IO次数更少
2. 所有查询都要查找到叶⼦节点，查询性能稳定
3. 所有叶⼦节点形成有序链表，便于范围查

B+树索引是B+树在数据库中实现，特点是高扇出性，在数据库中，B+树的高度一般都在2~4层，也就是说查找某一键值的行记录时最多只需要2~4次IO。

B+树索引hash树索引的区别？

（1）Hash索引不能进行范围查询，而B+树可以。

这是因为Hash索引指向的数据是无序的，而B+ 树的叶子节点是个有序的链表。


（2）Hash索引不支持联合索引的最左侧原则（即联合索引的部分索引无法使用），而B+树可以。

对于联合索引来说，Hash索引在计算Hash值的时候是将索引键合并后再一起计算Hash值，所以不会针对每个索引单独计算Hash值。因此如果用到联合索引的一个或多个索引时，联合索引无法被利用。

（3）Hash索引不支持Order BY排序，而B+树支持。

因为Hash索引指向的数据是无序的，因此无法起到排序优化的作用，而B+树索引数据是有序的，可以起到对该字段Order By 排序优化的作用。

（4）Hash索引无法进行模糊查询。
而B+ 树使用 LIKE 进行模糊查询的时候，LIKE后面前模糊查询（比如%开头）的话可以起到优化的作用。

（5）Hash索引在等值查询上比B+树效率更高。


为什么不是一般二叉树?

如果二叉树特殊化为一个链表，相当于全表扫描。平衡二叉树相比于二叉查找树来说，查找效率更稳定，总体的查找速度也更快。

为什么不是平衡二叉树呢?

我们知道，在内存比在磁盘的数据，查询效率快得多。如果树这种数据结构作为索引， 那我们每查找一次数据就需要从磁盘中读取一个节点，也就是我们说的一个磁盘块，但是平衡二叉树可是每个节点只存储一个键值和数据的，如果是B树，可以存储更多的节点数据，树的高度也会降低，因此读取磁盘的次数就降下来啦，查询效率就快啦。

那为什么不是B树而是B+树呢?

- 1)B+树非叶子节点上是不存储数据的，仅存储键值，而B树节点中不仅存储键值， 也会存储数据。innodb中⻚的默认大小是16KB，如果不存储数据，那么就会存储更多的键值，相应的树的阶数(节点的子节点树)就会更大，树就会更矮更胖，如此一来我们查找数据进行磁盘的IO次数有会再次减少，数据查询的效率也会更快。
- 2)B+树索引的所有数据均存储在叶子节点，而且数据是按照顺序排列的，链表连着的。那么B+树使得范围查找，排序查找，分组查找以及去重查找变得异常简单。

### 1.3 索引类型
索引按数据结构分类：B+树索引、全文索引、哈希索引
索引按物理存储分类：聚集索引和非聚集索引
   
### 1.4 聚集索引和非聚集索引的区别

聚集索引：类似汉语字典的拼音检索.

非聚集索引：类似汉语字典里的偏旁检索。除了聚集索引以外的索引都是非聚集索引，可细分成普通索引，唯一索引，全文索引。

非聚集索引的存储结构与聚集索引是一样的，不同的是在叶子结点的数据部分存的不再是具体的数据，而数据的聚集索引的key。所以通过非聚集索引查找的过程是先找到该索引key对应的聚集索引的key，然后再拿聚集索引的key到主键索引树上查找对应的数据，这个过程称为**回表**！

两种索引相同点：

内部都是 B+ 树，高度平衡，叶子节点存放着所有的数据。

不同点：

| 聚集索引 | 非聚集索引 |
| --- | --- |
| 以主键创建的索引，在叶子节点存储的是表中的数据 | 以非主键创建的索引(也叫做二级索引)，在叶子节点存储的是主键和索引列。 |
| 聚集索引每张表只能有一个 | 非聚集索引可以有多个 |
| 聚集索引物理上连续存在 | 非聚集索引逻辑上的连续，物理存储不连续 |
| 表记录的排列顺序和索引的排列顺序一致；所以查询效率快，因为只要找到第一个索引值记录，其余的连续性的记录在物理表中也会连续存放，一起就可以查询到。
缺点：新增比较慢，因为为了保证表中记录的物理顺序和索引顺序一致，在记录插入的时候，会对数据页重新排序。 | 表记录的排列顺序和索引的排列顺序不一致。 |

1.5 联合索引，最有原则


## 2. 引擎有哪些？有什么区别 middle

innoDB和MyISAM的区别

|  | InnoDB | MyISAM |
| --- | --- | --- |
| 事务 | 支持 | 不支持 |
| 外键 | 支持 | 不支持 |
| MVCC(多版本并发控制) | 支持 | 不支持 |
| 事务 | 提供了具有提交、回滚、崩溃恢复能力的事务安全；写的效率差一些，并且会占用更多的磁盘空间以保留数据和索引 | 不支持 |
| 主键 | 必须有主键 | 可以没有主键 |
| select count(*) from table; | 需要全表扫描 | 更快，因为它有一个变量保存了整个表的总行数，可以直接读取 |
| 全文索引 | 不支持 | 支持 |
| 锁 | 支持表、行级锁 | 支持表级锁 |
| 内存和存储 | 占用更多 | 可被压缩，存储空间较小 |
| 数据插入顺序 | 按主键大小有序插入 | 按记录插入顺序保存 |
|  | 索引组织表，使用共享表空间和多表空间储存数据 | 用 .frm 、 .MYD 、 .MTI 来储存表定义，数据和索引 |

## 3、事务以及事务的等级？high
1. 事务的特性、特性实现的原理

**事务的特性：ACID**

- 原子性(Atomicity)：事务必须是原子工作单元；对于其数据修改，要么全都执行，要么全都不执行。通常，与某个事务关联的操作具有共同的目标，并且是相互依赖的。如果系统只执行这些操作的一个子集，则可能会破坏事务的总体目标。原子性消除了系统处理操作子集的可能性。
- 一致性(Consistency)：事务结束后系统状态是一致的；事务将数据库从一种一致状态转变为下一种一致状态。也就是说，事务在完成时，必须使所有的数据都保持一致状态（各种 constraint 不被破坏）。
- 隔离性(Isolation)：由并发事务所作的修改必须与任何其它并发事务所作的修改隔离。事务查看数据时数据所处的状态，要么是另一并发事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看中间状态的数据。换句话说，一个事务的影响在该事务提交前对其他事务都不可见。
- 持久性(Durability)：事务完成之后，它对于系统的影响是永久性的。该修改即使出现致命的系统故障也将一直保持。通过日志和同步备份可以在故障发生后重建数据。

事务ACID特性的实现

- 原子性：是使用 undo log来实现的，如果事务执行过程中出错或者用户执行了 rollback，系统通过undo log日志返回事务开始的状态。
- 持久性：使用 redo log来实现，只要redo log日志持久化了，当系统崩溃，即可通 过redo log把数据恢复。
- 隔离性：通过锁以及MVCC，使事务相互隔离开。
- 一致性：通过回滚、恢复，以及并发情况下的隔离性，从而实现一致性。
    
2. 事务隔离级别，各个隔离级别解决的问题

SQL中**四种事务隔离级别**

- **读未提交（READ UNCOMMITTED）**：事务可以读取其它事务未提交的数据。

  Read Uncommitted允许脏读。

- **读已提交（READ COMMITTED）**：一个事务只能读取到已经提交事务的改变。Oracle等多数数据库默认都是该级别。

  Read Commited 不允许脏读，但会出现非重复读。

- **可重复读（REPEATABLE READ）**：在同一个事务里面先后执行同一个查询语句的时候，得到的结果是一样的。可重复读也是 mysql 的默认隔离级别。

  Repeatable Read 不允许脏读，不允许非重复读，但是会出现幻象读。

- **可串行化（SERIALIZABLE）**：这个事务执行的时候不允许别的事务并发执行。完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞。

  Serializable 不允许不一致现象的出现。


**如果不对数据库进行并发控制，可能会产生异常情况：**

- 脏读（Dirty Read）

当一个事务读取另一个事务尚未提交的修改时，产生脏读。

同一事务内不是脏读。 一个事务开始读取了某行数据，但是另外一个事务已经更新了此数据但没有能够及时提交。这是相当危险的，因为很可能所有的操作都被回滚，也就是说读取出的数据其实是错误的。

- 非重复读（Nonrepeatable Read）

一个事务对同一行数据重复读取两次，但是却得到了不同的结果。同一查询在同一事务中多次进行，由于其他提交事务所做的修改或删除，每次返回不同的结果集，此时发生非重复读。

- 幻像读（Phantom Read）

事务在操作过程中进行两次查询，第二次查询的结果包含了第一次查询中未出现的数据（这里并不要求两次查询的SQL语句相同）。这是因为在两次查询过程中有另外一个事务插入数据造成的。

当对某行执行插入或删除操作，而该行属于某个事务正在读取的行的范围时，会发生幻像读问题。

- 丢失修改(Lost Update)

第一类：当两个事务更新相同的数据源，如果第一个事务被提交，第二个却被撤销，那么连同第一个事务做的更新也被撤销。

第二类：有两个并发事务同时读取同一行数据，然后其中一个对它进行修改提交，而另一个也进行了修改提交。这就会造成第一次写操作失效。

## 3. MVCC的原理 middle

MVCC（Multi-Version Concurrency Control，多版本并发控制），本质是乐观锁的一种实现方式。它是通过读取历史版本的数据，来降低并发事务冲突，从而提高并发性能的一种机制。
[https://www.cnblogs.com/jelly12345/p/12425352.html](https://www.cnblogs.com/jelly12345/p/12425352.html)

InnoDB存储引擎MVCC的实现策略：

在每一行数据中额外保存两个隐藏的列：当前行创建时的版本号和删除时的版本号（可能为空，其实还有一列称为回滚指针，用于事务回滚，不在本文范畴）。每当开始新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询每行记录的版本号进行比较。

每个事务又有自己的版本号，这样事务内执行CRUD操作时，就通过版本号的比较来达到数据版本控制的目的。

MVCC需要关注这几个知识点:

- 事务版本号
- 表的隐藏列
- undo log
- read view

MVCC主要作用于事务性的，有行锁控制的数据库模型。

## 4. 锁 middle
1. 行锁，表锁，悲观锁啊，乐观锁啊，排它锁，共享锁，间隙锁，范围锁，临键锁，两阶段锁，死锁的原因


2. 事务中各个隔离级别用的锁的类型已经怎么用的锁


3. 分锁力度和锁算法（间隙锁、记录锁、临检锁），什么时候会用到


## 5. 数据结构 low
1. varchar和char的区别


2. int和int(11)区别


3. tinyint和int区别


## 6. 日志有哪几种 high
1. binlog日志种类，优缺点，一般怎么设置
   
3种格式：
STATEMENT：基于SQL语句的复制（statement-based replication, SBR）

ROW：基于行的复制（row-based replication, RBR）

MIXED：混合模式复制（mixed-based replication, MBR）

在 MySQL 5.7.7 之前，默认的格式是 STATEMENT，在 MySQL 5.7.7 及更高版本中，默认值是 ROW。日志格式通过 binlog-format 指定，如 binlog-format=STATEMENT、binlog-format=ROW、binlog-format=MIXED。

Statement  每一条会修改数据的sql都会记录在binlog中

优点：不需要记录每一行的变化，减少了binlog日志量，节约了IO, 提高了性能。

缺点：由于记录的只是执行语句，为了这些语句能在slave上正确运行，因此还必须记录每条语句在执行的时候的一些相关信息，以保证所有语句能在slave得到和在master端执行的时候相同的结果。另外mysql的复制，像一些特定函数的功能，slave与master要保持一致会有很多相关问题。

Row

5.1.5版本的MySQL才开始支持 row level 的复制,它不记录sql语句上下文相关信息，仅保存哪条记录被修改。

优点： binlog中可以不记录执行的sql语句的上下文相关的信息，仅需要记录那一条记录被修改成什么了。所以row的日志内容会非常清楚的记录下每一行数据修改的细节。而且不会出现某些特定情况下的存储过程，或function，以及trigger的调用和触发无法被正确复制的问题.

缺点:所有的执行的语句当记录到日志中的时候，都将以每行记录的修改来记录，这样可能会产生大量的日志内容。

注：将二进制日志格式设置为ROW时，有些更改仍然使用基于语句的格式，包括所有DDL语句，例如CREATE TABLE， ALTER TABLE，或 DROP TABLE。

Mixed

从5.1.8版本开始，MySQL提供了Mixed格式，实际上就是Statement与Row的结合。

在Mixed模式下，一般的语句修改使用statment格式保存binlog，如一些函数，statement无法完成主从复制的操作，则采用row格式保存binlog，MySQL会根据执行的每一条具体的sql语句来区分对待记录的日志形式，也就是在Statement和Row之间选择一种。

设置：
基本配制

Mysql BInlog日志格式可以通过mysql的my.cnf文件的属性binlog_format指定。如以下：

binlog_format           = MIXED                 //binlog日志格式

log_bin                     =目录/mysql-bin.log    //binlog日志名

expire_logs_days     = 7                //binlog过期清理时间

max_binlog_size      100m                    //binlog每个日志文件大小

**Binlog日志格式选择**

1、互联网公司，使用MySQL的功能相对少（存储过程、触发器、函数）

选择默认的语句模式，Statement Level（默认）

2、公司如果用到使用MySQL的特殊功能（存储过程、触发器、函数）

则选择Mixed模式

3、公司如果用到使用MySQL的特殊功能（存储过程、触发器、函数）又希望数据最大化一直，此时最好选择Row level模式


3. redo log、undo log 的使用

innodb有两种日志：

- redo logo（重做日志），用来恢复数据，实现事务的持久性。该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log）,前者是在内存中，后者在磁盘中。当**事务提交之后**
  会把所有修改信息都会存到该日志中。
- undo logo（回滚日志），用于记录数据**被修改前**的信息，用来回滚数据实现事务的原子性。

日志的存放形式

- undo：在 MySQL5.5 之前， undo 只能存放在 ibdata文件里面， 5.6 之后，可以 通过设置innodb_undo_tablespaces 参数把 undo log 存放在 ibdata之外。
- redo：在⻚修改的时候，先写到 redo log buffer 里面， 然后写到 redo log 的文件 系统缓存里面(fwrite)，然后再同步到磁盘文件( fsync)。

## 7. 高可用怎么部署（主从部署）middle
    1. 读写分离原理
    2. 主从同步慢如何解决
    3. 大批量删除数据，怎么快速释放内存
    4. delete会立即释放内存吗
    5. truncate和drop
## 8. 优化方式 分库分表规则，出现的问题 如何处理 middle
## 9. 慢查询 数据量大，查询慢，怎么解决的（执行计划、哪些参数）high
## 10. 正在运行的业务中，数据表修改字段如何避免锁表导致业务不可用的问题。
